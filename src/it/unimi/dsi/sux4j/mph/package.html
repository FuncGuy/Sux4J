<html>
<head><title>Minimal perfect hash functions</title></head>
<body>
Minimal perfect hash functions.

<h2>Package Specification</h2>

<p>This package provides a number of state-of-the-art implementations of static (i.e., immutable)
<em>minimal perfect hash functions</em>, and, more generally, of static functions from objects to integers.
The classes can be gathered in three broad groups:
<ul>
<li>General functions (e.g.,  {@link it.unimi.dsi.sux4j.mph.MWHCFunction}). They can be used to associate arbitrary values to a set of objects,
so, in particular, they can be used to implement <em>order-preserving minimal perfect hashing</em> (elements are mapped
to their order in which they were provided, independently of their lexicographical order). They are also essential
building blocks for all other classes.
<li>Minimal perfect hash functions (e.g., {@link it.unimi.dsi.sux4j.mph.MinimalPerfectHashFunction}); they map a set
of <var>n</var> object to the set <var>n</var> = { 0, 1,&hellip; <var>n</var> &minus; 1 }.
<li><em>Monotone</em> minimal perfect hash functions (e.g., {@link it.unimi.dsi.sux4j.mph.LcpMonotoneMinimalPerfectHashFunction},
{@link it.unimi.dsi.sux4j.mph.PaCoTrieMonotoneMinimalPerfectHashFunction}, {@link it.unimi.dsi.sux4j.mph.HollowTrie}
and {@link it.unimi.dsi.sux4j.mph.HollowTrieMonotoneMinimalPerfectHashFunction}). These
functions requires keys to be prefix-free and provided in lexicographical order; they will map back each key to its position using
a very small number of bits per element, providing different space/time tradeoffs (in what follows,
<var>l</var> is maximum the string length):
<ul>
<li>{@link it.unimi.dsi.sux4j.mph.LcpMonotoneMinimalPerfectHashFunction} is very fast, as it has just to evaluate three {@link it.unimi.dsi.sux4j.mph.MWHCFunction}s
(so if the length of the strings is a constant multiplied by the machine word, it is actually constant-time); however it uses 
2.7 + log log <var>n</var> + log <var>l</var> bits per element.</li>
<li>{@link it.unimi.dsi.sux4j.mph.PaCoTrieMonotoneMinimalPerfectHashFunction} is slower, as it uses a <em>{@linkplain it.unimi.dsi.sux4j.mph.BitstreamImmutablePaCoTrie partial compacted trie}</em>
(which requires linear time to be accessed) to distribute keys between buckets; theoretically it uses 
2.7 + 2 log <var>l</var> bits per element, but the partial compacted trie is every efficiency in exploiting data redundancy, so the actual
occupancy is in general half with respect to the previous function.</li>
<li>{@link it.unimi.dsi.sux4j.mph.HollowTrie} is <em>very</em> slow as it has to traverse a succinct trie on the whole key set; it
is mainly of theoretical interest, as it uses just 2 + log <var>l</var> bits per element, and also in practice it
occupies less space than the previous two functions.</li>
<li>{@link it.unimi.dsi.sux4j.mph.HollowTrieMonotoneMinimalPerfectHashFunction} is slow, as it
uses a {@linkplain it.unimi.dsi.sux4j.mph.HollowTrieDistributor enriched hollow trie as a distributor}, but it is faster than a hollow trie,
and it has the (quite surprising) property of using 3.44 + 1.23 log log <var>l</var> bits per element (note the double log). In practice,
it will use less than a byte per element for strings of length up to a billion bits.</li>
</ul>
</ul>

<p>All the above structures, with the exception of {@link it.unimi.dsi.sux4j.mph.MinimalPerfectHashFunction}, were introduced in
&ldquo;Monotone Minimal Perfect Hashing&rdquo;, by Djamal Belazzougui, Paolo Boldi, Rasmus Pagh and 
Sebastiano Vigna (the class {@link it.unimi.dsi.sux4j.mph.MWHCFunction} implements a <em>compacted</em> version
of the classical {@linkplain it.unimi.dsi.sux4j.mph.HypergraphSorter 3-hypergraph-based structure} introduced therein).

<h2>Usage</h2>

<p>Functions in this package implement the {@link it.unimi.dsi.fastutil.objects.Object2LongFunction} interface. However,
the underlying machinery manipulates {@linkplain it.unimi.dsi.bits.BitVector bit vectors} only. To bring you own data
into the bit vector world, each contructor requires to specify a {@linkplain it.unimi.dsi.bits.TransformationStrategy transformation strategy}
that maps your objects into bit vectors. For instance, {@link it.unimi.dsi.bits.TransformationStrategies#utf16()},
{@link it.unimi.dsi.bits.TransformationStrategies#prefixFreeUtf16()}, {@link it.unimi.dsi.bits.TransformationStrategies#iso()},
and {@link it.unimi.dsi.bits.TransformationStrategies#prefixFreeIso()} are ready-made strategies that can be used with character sequences.

<p>Note that if you plain to use monotone hashing, you must provide objects in an order such that the corresponding bit vectors
are lexicographically ordered. For instance, {@link it.unimi.dsi.bits.TransformationStrategies#utf16()} obtain this
results by concatenating the <em>reversed</em> 16-bit representation of each character.

<h2>Signing functions</h2>

<p>All functions in this package will return a value in their range for most of the keys that are not in their domain. In other
words, they will produce false positives; in the few cases in which it is possible to detect a negative, you will get the default return
value. </p>

<p>If you are interested in getting a more precise behaviour (e.g., you are migrating from the deprecated <code>SignedMinimalPerfectHash</code>
class that was distributed with <a href="http://mg4j.dsi.unimi.it/">MG4J</a>), you can <em>sign</em> a map, that is, you can record
a signature for each key and use it to filter false positives. A signing class for character sequences is provided 
by the <a href="http://dsiutils.dsi.unimi.it/">DSI utilities</a> class
<a href="http://dsiutils.dsi.unimi.it/docs/it/unimi/dsi/util/ShiftAddXorSignedStringMap.html">ShiftAddXorSignedStringMap</a>. By
creating a function using one of the implementation provided with Sux4J and signing it using the above class, you can obtain the same functionality of
the old signed classes, but you can choose the size of the signature, whether to require monotonicity, and also the space/time tradeoff
of your function.
 
</body>
</html>
