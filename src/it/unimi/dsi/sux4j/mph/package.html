<html>
<head><title>Minimal perfect hash functions</title></head>
<body>
Minimal perfect hash functions.

<h2>Package Specification</h2>

<p>This package provides a number of state-of-the-art implementations of static (i.e., immutable)
<em>minimal perfect hash functions</em>, and, more generally, of static functions from objects to integers.
The classes can be gathered in three broad groups:
<ul>
<li>General functions (e.g.,  {@link it.unimi.dsi.sux4j.mph.MWHCFunction} and {@link it.unimi.dsi.sux4j.mph.TwoStepsMWHCFunction}). They can be used to associate arbitrary values to a set of objects,
so, in particular, they can be used to implement <em>order-preserving minimal perfect hashing</em> (elements are mapped
to their order in which they were provided, independently of their lexicographical order). They are also essential
building blocks for all other classes.
<li>Minimal perfect hash functions (e.g., {@link it.unimi.dsi.sux4j.mph.MinimalPerfectHashFunction}); they map a set
of <var>n</var> object to the set <var>n</var> = { 0, 1,&hellip; <var>n</var> &minus; 1 }.
<li><em>Monotone</em> minimal perfect hash functions (e.g., {@link it.unimi.dsi.sux4j.mph.LcpMonotoneMinimalPerfectHashFunction},
{@link it.unimi.dsi.sux4j.mph.PaCoTrieDistributorMonotoneMinimalPerfectHashFunction}, {@link it.unimi.dsi.sux4j.mph.HollowTrieMonotoneMinimalPerfectHashFunction}
and {@link it.unimi.dsi.sux4j.mph.HollowTrieDistributorMonotoneMinimalPerfectHashFunction}). These
functions requires keys to be prefix-free and provided in lexicographical order; they will map back each key to its position using
a very small number of bits per element, providing different space/time tradeoffs (in what follows,
&#x2113; is the maximum string length):
<ul>
<li>{@link it.unimi.dsi.sux4j.mph.LcpMonotoneMinimalPerfectHashFunction} is very fast, as it has just to evaluate three {@link it.unimi.dsi.sux4j.mph.MWHCFunction}s
(so if the length of the strings is a constant multiplied by the machine word, it is actually constant time); however it uses 
2.14 + log log <var>n</var> + log &#x2113; bits per element. {@link it.unimi.dsi.sux4j.mph.TwoStepsLcpMonotoneMinimalPerfectHashFunction} gains
a few bits by performing some additional compression, but it is usually slightly slower (albeit always constant time).</li>
<li>{@link it.unimi.dsi.sux4j.mph.PaCoTrieDistributorMonotoneMinimalPerfectHashFunction} is slower, as it uses a <em>{@linkplain it.unimi.dsi.sux4j.mph.PaCoTrieDistributor partial compacted trie}</em>
(which requires linear time to be accessed) to distribute keys between buckets; theoretically it uses 
2.14 + log(&#x2113; - log <var>n</var>)  bits per element, but the partial compacted trie is every efficiency in exploiting data redundancy, so the actual
occupancy is in general half with respect to the previous function.</li>
<li>{@link it.unimi.dsi.sux4j.mph.HollowTrieMonotoneMinimalPerfectHashFunction} is <em>rather</em> slow as it has to traverse a succinct trie on the whole key set; 
it uses just 4 + log &#x2113; + log log &#x2113; bits per element, and in practice it
is the monotone minimal perfect hash function that uses less space.</li>
<li>{@link it.unimi.dsi.sux4j.mph.HollowTrieDistributorMonotoneMinimalPerfectHashFunction} is slow, as it
uses a {@linkplain it.unimi.dsi.sux4j.mph.HollowTrieMonotoneMinimalPerfectHashFunction enriched hollow trie as a distributor}, but it is faster than a hollow trie,
and it has the (quite surprising) property of using 3.21 + 1.23 log log &#x2113; bits per element (note the double log). In practice,
it will use less than a byte per element for strings of length up to a billion bits.</li>
<li>{@link it.unimi.dsi.sux4j.mph.ZFastTrieDistributorMonotoneMinimalPerfectHashFunction} is faster than
{@link it.unimi.dsi.sux4j.mph.HollowTrieDistributorMonotoneMinimalPerfectHashFunction}, but occupies in practice more space,
even if, from an asymptotic viewpoint, the space required is the same. Presently it is mainly of theoretical interest, but
it has the best behaviour when scaling to very large data sets (billions of strings).</li>
<li>Variable-length versions (e.g., {@link it.unimi.dsi.sux4j.mph.VLLcpMonotoneMinimalPerfectHashFunction} and
{@link it.unimi.dsi.sux4j.mph.VLPaCoTrieDistributorMonotoneMinimalPerfectHashFunction}) are structures whose size depends
on the <em>average</em>, rather than on the <em>maximum</em> string length, but they are mainly of theoretical interest.
</ul>
</ul>

<p>{@link it.unimi.dsi.sux4j.mph.LcpMonotoneMinimalPerfectHashFunction} and {@link it.unimi.dsi.sux4j.mph.ZFastTrieDistributorMonotoneMinimalPerfectHashFunction}
were introduced by Djamal Belazzougui, Paolo Boldi, Rasmus Pagh and Sebastiano Vigna
in &ldquo;Monotone Minimal Perfect Hashing: Searching a Sorted Table with <i>O</i>(1) Accesses&rdquo;, 
Proc. of the 20th Annual ACM&ndash;SIAM Symposium On Discrete Mathematics (SODA), ACM Press, 2009.
{@link it.unimi.dsi.sux4j.mph.TwoStepsLcpMonotoneMinimalPerfectHashFunction}, {@link it.unimi.dsi.sux4j.mph.PaCoTrieDistributorMonotoneMinimalPerfectHashFunction},
 {@link it.unimi.dsi.sux4j.mph.HollowTrieMonotoneMinimalPerfectHashFunction} and {@link it.unimi.dsi.sux4j.mph.HollowTrieDistributorMonotoneMinimalPerfectHashFunction} were introduced
 by the same authors in &ldquo;Theory and practice of monotone minimal perfect hashing&rdquo;, <i>ACM Journal of Experimental Algorithmics</i>, 
 16(3):132&minus;144, 2011 (the class {@link it.unimi.dsi.sux4j.mph.MWHCFunction} implements a <em>compacted</em> version therein introduced
of the classical {@linkplain it.unimi.dsi.sux4j.mph.HypergraphSorter 3-hypergraph-based structure}).

<h2>Usage</h2>

<p>Functions in this package implement the {@link it.unimi.dsi.fastutil.objects.Object2LongFunction} interface. However,
the underlying machinery manipulates {@linkplain it.unimi.dsi.bits.BitVector bit vectors} only. To bring you own data
into the bit vector world, each constructor requires to specify a {@linkplain it.unimi.dsi.bits.TransformationStrategy transformation strategy}
that maps your objects into bit vectors. For instance, {@link it.unimi.dsi.bits.TransformationStrategies#utf16()},
{@link it.unimi.dsi.bits.TransformationStrategies#prefixFreeUtf16()}, {@link it.unimi.dsi.bits.TransformationStrategies#iso()},
and {@link it.unimi.dsi.bits.TransformationStrategies#prefixFreeIso()} are ready-made strategies that can be used with character sequences.

<p>Note that if you plain to use monotone hashing, you must provide objects in an order such that the corresponding bit vectors
are lexicographically ordered. For instance, {@link it.unimi.dsi.bits.TransformationStrategies#utf16()} obtain this
results by concatenating the <em>reversed</em> 16-bit representation of each character.

<h2>Signing functions</h2>

<p>All functions in this package will return a value in their range for most of the keys that are not in their domain. In other
words, they will produce false positives; in the few cases in which it is possible to detect a negative, you will get the default return
value. </p>

<p>If you are interested in getting a more precise behaviour, you can <em>sign</em> a function, that is, you can record
a signature for each key and use it to filter false positives. Several classes provide built-in signing (look at the methods of their builder).

<p>There are also external signing classes for character sequences provided 
by the <a href="http://dsiutils.dsi.unimi.it/">DSI utilities</a> which actually implement the interface
<a href="http://dsiutils.dsi.unimi.it/docs/it/unimi/dsi/util/StringMap.html">StringMap</a>, such as 
<a href="http://dsiutils.dsi.unimi.it/docs/it/unimi/dsi/util/ShiftAddXorSignedStringMap.html">ShiftAddXorSignedStringMap</a>;
<a href="http://dsiutils.dsi.unimi.it/docs/it/unimi/dsi/util/LiterallySignedStringMap.html">LiterallySignedStringMap</a>
will provide a full <a href="http://dsiutils.dsi.unimi.it/docs/it/unimi/dsi/util/StringMap.html">StringMap</a> implementation.
 
</body>
</html>
