package it.unimi.dsi.sux4j.io;


/*		 
 * DSI utilities
 *
 * Copyright (C) 2005-2008 Sebastiano Vigna 
 *
 *  This library is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU Lesser General Public License as published by the Free
 *  Software Foundation; either version 2.1 of the License, or (at your option)
 *  any later version.
 *
 *  This library is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 *  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
 *  for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *
 */

import it.unimi.dsi.fastutil.bytes.ByteArrays;
import it.unimi.dsi.fastutil.io.FastBufferedInputStream;
import it.unimi.dsi.fastutil.io.FastBufferedInputStream.LineTerminator;
import it.unimi.dsi.fastutil.longs.AbstractLongIterator;
import it.unimi.dsi.fastutil.objects.AbstractObjectList;
import it.unimi.dsi.lang.MutableString;
import it.unimi.dsi.sux4j.bits.SparseSelect;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.util.EnumSet;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.RandomAccess;
import java.util.zip.GZIPInputStream;

/** A wrapper exhibiting the lines of a file as a {@link java.util.Collection}.
 * 
 * <P><strong>Warning</strong>: the lines returned by iterators generated by
 * instances of this class <em>are not cacheable</em>. The returned value is
 * a {@link it.unimi.dsi.lang.MutableString} instance that is reused
 * at each call, and that is <em>modified by a call to {@link java.util.Iterator#hasNext() hasNext()}</em>. 
 * Thus, for instance,
 * <pre>
 *    ObjectIterators.unwrap( fileLinesColletion.iterator() );
 * </pre>
 * will not give the expected results.
 * Note that {@link #toString()} will return a single string containing all
 * file lines separated by a newline.
 * 
 * <P>An instance of this class allows to access the lines of a file as a
 * {@link java.util.Collection}. Using {@linkplain java.util.Collection#contains(java.lang.Object)
 * direct access} is strongly discouraged (it will require a full scan of the file), but
 * the {@link #iterator()} can be fruitfully used to scan the file, and can be called any
 * number of times, as it opens an independent input stream at each call. For the
 * same reason, the returned iterator type ({@link FileLinesList.FileLinesIterator})
 * is {@link java.io.Closeable}, and should be closed after usage.
 * 
 * <p>Using a suitable {@linkplain #FileLinesCollection(CharSequence, String, boolean) constructor}, it is possible
 * to specify that the file is compresse in <samp>gzip</samp> format (in this case, it will be opened using a {@link GZIPInputStream}).
 * 
 * <P>Note that the first call to {@link #size()} will require a full file scan.  
 * 
 * @author Sebastiano Vigna
 * @since 0.9.2
 */
public class FileLinesList extends AbstractObjectList<MutableString> implements RandomAccess {
	/** The filename upon which this file-lines collection is based. */
	private final String filename;
	/** The size of the list. */
	private final int size;
	/** The buffer size for all instances of {@link FastBufferedInputStream}. */
	private final int bufferSize;
	private final EnumSet<LineTerminator> terminators;
	
	private final ByteBuffer byteBuffer;
	private final CharBuffer charBuffer;
	private SparseSelect select;
	private final FastBufferedInputStream inputStream;
	private InputStreamReader inputStreamReader;
	private CharsetDecoder decoder;
	
	/** Creates a file-lines collection for the specified filename with the specified encoding, buffer size and terminator set.
	 * 
	 * @param filename a filename.
	 * @param encoding an encoding.
	 * @param bufferSize the buffer size for {@link FastBufferedInputStream}.
	 * @param terminators a set of {@link FastBufferedInputStream.LineTerminator}s.
	 */		
	public FileLinesList( final CharSequence filename, final String encoding, final int bufferSize, final EnumSet<FastBufferedInputStream.LineTerminator> terminators ) throws IOException {
		this.bufferSize = bufferSize;
		this.terminators = terminators;
		this.filename = filename.toString();
		
		inputStream = new FastBufferedInputStream( new FileInputStream( this.filename ), bufferSize );
		decoder = Charset.forName( encoding ).newDecoder();
		byte[] array = new byte[ 16 ];
		int count = 0, start, len;

		for(;;) {
			start = 0;
			while( ( len = inputStream.readLine( array, start, array.length - start, terminators ) ) == array.length - start ) {
				start += len;
				array = ByteArrays.grow( array, array.length + 1 );
			};
			
			if ( len != -1 ) count++;
			else break;
		}

		size = count;
		byteBuffer = ByteBuffer.wrap( array );
		charBuffer = CharBuffer.wrap( new char[ array.length ] );
		
		inputStream.position( 0 );
		select = new SparseSelect( inputStream.length() + 1, count + 1, new AbstractLongIterator() {
			boolean toAdvance = false;
			long pos = 0;
			byte[] buffer = byteBuffer.array();
			
			public boolean hasNext() {
				if ( toAdvance ) try {
					final int result = inputStream.readLine( buffer, terminators );
					pos = result == -1 ? -1 : inputStream.position();
					toAdvance = false;
				}
				catch ( IOException e ) {
					throw new RuntimeException( e );
				}
				
				return pos != -1;
			}
			
			public long nextLong() {
				if ( ! hasNext() ) throw new NoSuchElementException();
				toAdvance = true;
				return pos;
			}
		});
	}

	/** Creates a file-lines collection for the specified filename with the specified encoding, buffer size and with all terminators.
	 * 
	 * @param filename a filename.
	 * @param encoding an encoding.
	 * @param bufferSize the buffer size for {@link FastBufferedInputStream}.
	 */		
	public FileLinesList( final CharSequence filename, final String encoding, final int bufferSize ) throws IOException {
		this( filename, encoding, bufferSize, FastBufferedInputStream.ALL_TERMINATORS );
	}
		
	/** Creates a file-lines collection for the specified filename with the specified encoding, default buffer size and with all terminators.
	 * 
	 * @param filename a filename.
	 * @param encoding an encoding.
	 */		
	public FileLinesList( final CharSequence filename, final String encoding ) throws IOException {
		this( filename, encoding, FastBufferedInputStream.DEFAULT_BUFFER_SIZE );
	}
		
	public int size() {
		return size;
	}
		
	public String toString() {
		MutableString s = new MutableString();
		for( Iterator<MutableString> i = iterator(); i.hasNext(); ) s.append( i.next() ).append( '\n' );
		return s.toString();
	}

	public MutableString get( int index ) {
		try {
			inputStream.position( select.select( index ) );
			byteBuffer.clear();
			byteBuffer.limit( inputStream.readLine( byteBuffer.array(), terminators ) );
			charBuffer.clear();
			decoder.decode( byteBuffer, charBuffer, true );
			return MutableString.wrap( charBuffer.array(), charBuffer.position() );
		}
		catch ( IOException e ) {
			throw new RuntimeException( e );
		}
	}
}
