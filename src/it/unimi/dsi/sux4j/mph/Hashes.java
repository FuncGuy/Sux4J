package it.unimi.dsi.sux4j.mph;

/*		 
 * Sux4J: Succinct data structures for Java
 *
 * Copyright (C) 2008 Sebastiano Vigna 
 *
 *  This library is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU Lesser General Public License as published by the Free
 *  Software Foundation; either version 2.1 of the License, or (at your option)
 *  any later version.
 *
 *  This library is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 *  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
 *  for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *
 */

import it.unimi.dsi.bits.BitVector;

/** Basic hash functions.
 * 
 */
public class Hashes {

	private Hashes() {}
	
	/** Jenkins 64-bit hashing (all three values produced).
	 * 
	 * <p>This code is based on the <samp><a href="http://www.burtleburtle.net/bob/c/lookup8.c">lookup8.c</a></samp>, and in particular
	 * on the version consuming 64 bits at a time, but it has been slightly modified to work correctly with any bit vector length (not just multiples of 64).
	 * Moreover, we return all three values generated by the algorithm.
	 * 
	 * @param bv a bit vector.
	 * @param seed a seed for the hash.
	 * @param h a triple of long values in which the three generated hashes will be saved.
	 */
	
	public static void jenkins( final BitVector bv, final long seed, final long[] h )  {
		final long length = bv.length();
		long a, b, c, from = 0;

		if ( bv.length() == 0 ) {
			h[ 0 ] = seed ^ 0x8de6a918d6538324L;
			h[ 1 ] = seed ^ 0x6bda2aef21654e7dL;
			h[ 2 ] = seed ^ 0x36071e726d0ba0c5L;
			return;
		}
		
		/* Set up the internal state */
		a = b = seed;
		c = 0x9e3779b97f4a7c13L; /* the golden ratio; an arbitrary value */

		while ( length - from > Long.SIZE * 2 ) {
			a += bv.getLong( from, from + Long.SIZE );
			b += bv.getLong( from + Long.SIZE, from + 2 * Long.SIZE );
			c += bv.getLong( from + 2 * Long.SIZE, Math.min( from + 3 * Long.SIZE, length ) );

			a -= b; a -= c; a ^= (c >>> 43);
			b -= c; b -= a; b ^= (a << 9);
			c -= a; c -= b; c ^= (b >>> 8);
			a -= b; a -= c; a ^= (c >>> 38);
			b -= c; b -= a; b ^= (a << 23);
			c -= a; c -= b; c ^= (b >>> 5);
			a -= b; a -= c; a ^= (c >>> 35);
			b -= c; b -= a; b ^= (a << 49);
			c -= a; c -= b; c ^= (b >>> 11);
			a -= b; a -= c; a ^= (c >>> 12);
			b -= c; b -= a; b ^= (a << 18);
			c -= a; c -= b; c ^= (b >>> 22);

			from += 3 * Long.SIZE;
		}

		c += length << 3;
		long residual = length - from;
		if ( residual > 0 ) {
			if ( residual > Long.SIZE ) {
				a += bv.getLong( from, from + Long.SIZE );
				residual -= Long.SIZE;
			}
			if ( residual != 0 ) b += bv.getLong( length - residual, length );
		}

		a -= b; a -= c; a ^= (c >>> 43);
		b -= c; b -= a; b ^= (a << 9);
		c -= a; c -= b; c ^= (b >>> 8);
		a -= b; a -= c; a ^= (c >>> 38);
		b -= c; b -= a; b ^= (a << 23);
		c -= a; c -= b; c ^= (b >>> 5);
		a -= b; a -= c; a ^= (c >>> 35);
		b -= c; b -= a; b ^= (a << 49);
		c -= a; c -= b; c ^= (b >>> 11);
		a -= b; a -= c; a ^= (c >>> 12);
		b -= c; b -= a; b ^= (a << 18);
		c -= a; c -= b; c ^= (b >>> 22);

		h[ 0 ] = a;
		h[ 1 ] = b;
		h[ 2 ] = c;
	}

	/** Jenkins 64-bit hashing.
	 * 
	 * @param bv a bit vector.
	 * @param seed a seed for the hash.
	 * @return the first of the three hash values returned by {@link #jenkins(BitVector, long, long[])}.
	 */
	
	public static long jenkins( final BitVector bv, final long seed)  {
		final long length = bv.length();
		long a, b, c, from = 0;

		if ( bv.length() == 0 ) return seed ^ 0x8de6a918d6538324L;
		
		/* Set up the internal state */
		a = b = seed;
		c = 0x9e3779b97f4a7c13L; /* the golden ratio; an arbitrary value */

		while ( length - from > Long.SIZE * 2 ) {
			a += bv.getLong( from, from + Long.SIZE );
			b += bv.getLong( from + Long.SIZE, from + 2 * Long.SIZE );
			c += bv.getLong( from + 2 * Long.SIZE, Math.min( from + 3 * Long.SIZE, length ) );

			a -= b; a -= c; a ^= (c >>> 43);
			b -= c; b -= a; b ^= (a << 9);
			c -= a; c -= b; c ^= (b >>> 8);
			a -= b; a -= c; a ^= (c >>> 38);
			b -= c; b -= a; b ^= (a << 23);
			c -= a; c -= b; c ^= (b >>> 5);
			a -= b; a -= c; a ^= (c >>> 35);
			b -= c; b -= a; b ^= (a << 49);
			c -= a; c -= b; c ^= (b >>> 11);
			a -= b; a -= c; a ^= (c >>> 12);
			b -= c; b -= a; b ^= (a << 18);
			c -= a; c -= b; c ^= (b >>> 22);

			from += 3 * Long.SIZE;
		}

		c += length << 3;
		long residual = length - from;
		if ( residual > 0 ) {
			if ( residual > Long.SIZE ) {
				a += bv.getLong( from, from + Long.SIZE );
				residual -= Long.SIZE;
			}
			if ( residual != 0 ) b += bv.getLong( length - residual, length );
		}

		a -= b; a -= c; a ^= (c >>> 43);
		b -= c; b -= a; b ^= (a << 9);
		c -= a; c -= b; c ^= (b >>> 8);
		a -= b; a -= c; a ^= (c >>> 38);
		b -= c; b -= a; b ^= (a << 23);
		c -= a; c -= b; c ^= (b >>> 5);
		a -= b; a -= c; a ^= (c >>> 35);
		b -= c; b -= a; b ^= (a << 49);
		c -= a; c -= b; c ^= (b >>> 11);
		a -= b; a -= c; a ^= (c >>> 12);
		b -= c; b -= a; b ^= (a << 18);
		c -= a; c -= b; c ^= (b >>> 22);

		return a;
	}

	/** Jenkins 64-bit hashing.
	 * 
	 * @param bv a bit vector.
	 * @return the first of the three hash values returned by {@link #jenkins(BitVector, long, long[])} with seed 0.
	 */
	public static long jenkins( final BitVector bv )  {
		return jenkins( bv, 0 );
	}


	/** Preprocesses a bit vector so that Jenkins 64-bit hashing can be computed in constant time on all prefixes.
	 * 
	 * @param bv a bit vector.
	 * @param seed a seed for the hash.
	 * @return an array of three element; each element is an array containing the state of the variables <code>a</code>, <code>b</code> and <code>c</code>
	 * during the hash computation; these vector must be passed to {@link #jenkins(BitVector, long, long[], long[], long[])} (and analogous functions) in this order. 
	 * @see #jenkins(BitVector)
	 */
	
	public static long[][] preprocessJenkins( final BitVector bv, final long seed )  {
		final long length = bv.length();
		final int wordLength = (int)( bv.length() / ( Long.SIZE * 3 ) ) + 1;
		final long aa[] = new long[ wordLength ], bb[] = new long[ wordLength ], cc[] = new long[ wordLength ];
		long a, b, c, from = 0;

		if ( aa.length == 0 ) return new long[ 3 ][ 0 ];
		
		int i = 0;

		/* Set up the internal state */
		a = b = seed;
		c = 0x9e3779b97f4a7c13L; /* the golden ratio; an arbitrary value */

		aa[ i ] = a;
		bb[ i ] = b;
		cc[ i ] = c;
		i++;

		while ( length - from >= Long.SIZE * 3 ) {
			a += bv.getLong( from, from + Long.SIZE );
			b += bv.getLong( from + Long.SIZE, from + 2 * Long.SIZE );
			c += bv.getLong( from + 2 * Long.SIZE, Math.min( from + 3 * Long.SIZE, length ) );

			a -= b; a -= c; a ^= (c >>> 43);
			b -= c; b -= a; b ^= (a << 9);
			c -= a; c -= b; c ^= (b >>> 8);
			a -= b; a -= c; a ^= (c >>> 38);
			b -= c; b -= a; b ^= (a << 23);
			c -= a; c -= b; c ^= (b >>> 5);
			a -= b; a -= c; a ^= (c >>> 35);
			b -= c; b -= a; b ^= (a << 49);
			c -= a; c -= b; c ^= (b >>> 11);
			a -= b; a -= c; a ^= (c >>> 12);
			b -= c; b -= a; b ^= (a << 18);
			c -= a; c -= b; c ^= (b >>> 22);

			from += 3 * Long.SIZE;
			
			aa[ i ] = a;
			bb[ i ] = b;
			cc[ i ] = c;
			i++;
		}
		
		return new long[][]{ aa, bb, cc };
	}

	/** Constant-time Jenkins 64-bit hashing for any prefix (all three values produced).
	 * 
	 * @param bv a bit vector.
	 * @param prefixLength the length of the prefix of <code>bv</code> over which the hash must be computed.
	 * @param aa the first state array returned by {@link #preprocessJenkins(BitVector, long)}.
	 * @param bb the second state array returned by {@link #preprocessJenkins(BitVector, long)}.
	 * @param cc the third state array returned by {@link #preprocessJenkins(BitVector, long)}.
	 * @param h a triple of long values in which the three generated hashes will be saved.
	 */
	
	public static void jenkins( final BitVector bv, final long prefixLength, final long[] aa, final long bb[], final long cc[], final long[] h )  {
		if ( prefixLength == 0 ) {
			final long seed = aa[ 0 ];
			h[ 0 ] = seed ^ 0x8de6a918d6538324L;
			h[ 1 ] = seed ^ 0x6bda2aef21654e7dL;
			h[ 2 ] = seed ^ 0x36071e726d0ba0c5L;
			return;
		}
		
		int stateOffset = (int)( prefixLength / ( 3 * Long.SIZE ) );
		long from = ( stateOffset * 3 ) * Long.SIZE;
		long a = aa[ stateOffset ];
		long b = bb[ stateOffset ];
		long c = cc[ stateOffset ];

		if ( prefixLength - from > Long.SIZE * 2 ) {
			a += bv.getLong( from, from + Long.SIZE );
			b += bv.getLong( from + Long.SIZE, from + 2 * Long.SIZE );
			c += bv.getLong( from + 2 * Long.SIZE, Math.min( from + 3 * Long.SIZE, prefixLength ) );

			a -= b; a -= c; a ^= (c >>> 43);
			b -= c; b -= a; b ^= (a << 9);
			c -= a; c -= b; c ^= (b >>> 8);
			a -= b; a -= c; a ^= (c >>> 38);
			b -= c; b -= a; b ^= (a << 23);
			c -= a; c -= b; c ^= (b >>> 5);
			a -= b; a -= c; a ^= (c >>> 35);
			b -= c; b -= a; b ^= (a << 49);
			c -= a; c -= b; c ^= (b >>> 11);
			a -= b; a -= c; a ^= (c >>> 12);
			b -= c; b -= a; b ^= (a << 18);
			c -= a; c -= b; c ^= (b >>> 22);

			from += 3 * Long.SIZE;
		}


		c += prefixLength << 3;
		long residual = prefixLength - from;
		if ( residual > 0 ) {
			if ( residual > Long.SIZE ) {
				assert from + Long.SIZE <= prefixLength;
				a += bv.getLong( from, from + Long.SIZE );
				residual -= Long.SIZE;
			}
			if ( residual != 0 ) b += bv.getLong( prefixLength - residual, prefixLength );
		}

		a -= b; a -= c; a ^= (c >>> 43);
		b -= c; b -= a; b ^= (a << 9);
		c -= a; c -= b; c ^= (b >>> 8);
		a -= b; a -= c; a ^= (c >>> 38);
		b -= c; b -= a; b ^= (a << 23);
		c -= a; c -= b; c ^= (b >>> 5);
		a -= b; a -= c; a ^= (c >>> 35);
		b -= c; b -= a; b ^= (a << 49);
		c -= a; c -= b; c ^= (b >>> 11);
		a -= b; a -= c; a ^= (c >>> 12);
		b -= c; b -= a; b ^= (a << 18);
		c -= a; c -= b; c ^= (b >>> 22);

		h[ 0 ] = a;
		h[ 1 ] = b;
		h[ 2 ] = c;
	}

	/** Constant-time Jenkins 64-bit hashing for any prefix.
	 * 
	 * @param bv a bit vector.
	 * @param prefixLength the length of the prefix of <code>bv</code> over which the hash must be computed.
	 * @param aa the first state array returned by {@link #preprocessJenkins(BitVector, long)}.
	 * @param bb the second state array returned by {@link #preprocessJenkins(BitVector, long)}.
	 * @param cc the third state array returned by {@link #preprocessJenkins(BitVector, long)}.
	 * @return the first of the three hash values returned by {@link #jenkins(BitVector, long, long[], long[], long[], long[])}.
	 */
	
	public static long jenkins( final BitVector bv, final long prefixLength, final long[] aa, final long bb[], final long cc[] )  {
		if ( prefixLength == 0 ) return aa[ 0 ] ^ 0x8de6a918d6538324L;
		
		int stateOffset = (int)( prefixLength / ( 3 * Long.SIZE ) );
		long from = ( stateOffset * 3 ) * Long.SIZE;
		long a = aa[ stateOffset ];
		long b = bb[ stateOffset ];
		long c = cc[ stateOffset ];

		if ( prefixLength - from > Long.SIZE * 2 ) {
			a += bv.getLong( from, from + Long.SIZE );
			b += bv.getLong( from + Long.SIZE, from + 2 * Long.SIZE );
			c += bv.getLong( from + 2 * Long.SIZE, Math.min( from + 3 * Long.SIZE, prefixLength ) );

			a -= b; a -= c; a ^= (c >>> 43);
			b -= c; b -= a; b ^= (a << 9);
			c -= a; c -= b; c ^= (b >>> 8);
			a -= b; a -= c; a ^= (c >>> 38);
			b -= c; b -= a; b ^= (a << 23);
			c -= a; c -= b; c ^= (b >>> 5);
			a -= b; a -= c; a ^= (c >>> 35);
			b -= c; b -= a; b ^= (a << 49);
			c -= a; c -= b; c ^= (b >>> 11);
			a -= b; a -= c; a ^= (c >>> 12);
			b -= c; b -= a; b ^= (a << 18);
			c -= a; c -= b; c ^= (b >>> 22);

			from += 3 * Long.SIZE;
		}


		c += prefixLength << 3;
		long residual = prefixLength - from;
		if ( residual > 0 ) {
			if ( residual > Long.SIZE ) {
				assert from + Long.SIZE <= prefixLength;
				a += bv.getLong( from, from + Long.SIZE );
				residual -= Long.SIZE;
			}
			if ( residual != 0 ) b += bv.getLong( prefixLength - residual, prefixLength );
		}

		a -= b; a -= c; a ^= (c >>> 43);
		b -= c; b -= a; b ^= (a << 9);
		c -= a; c -= b; c ^= (b >>> 8);
		a -= b; a -= c; a ^= (c >>> 38);
		b -= c; b -= a; b ^= (a << 23);
		c -= a; c -= b; c ^= (b >>> 5);
		a -= b; a -= c; a ^= (c >>> 35);
		b -= c; b -= a; b ^= (a << 49);
		c -= a; c -= b; c ^= (b >>> 11);
		a -= b; a -= c; a ^= (c >>> 12);
		b -= c; b -= a; b ^= (a << 18);
		c -= a; c -= b; c ^= (b >>> 22);

		return a;
	}
}
