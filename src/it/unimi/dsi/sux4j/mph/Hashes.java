package it.unimi.dsi.sux4j.mph;

/*		 
 * Sux4J: Succinct data structures for Java
 *
 * Copyright (C) 2008-2010 Sebastiano Vigna 
 *
 *  This library is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU Lesser General Public License as published by the Free
 *  Software Foundation; either version 2.1 of the License, or (at your option)
 *  any later version.
 *
 *  This library is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 *  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
 *  for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *
 */

import it.unimi.dsi.bits.BitVector;
import it.unimi.dsi.bits.LongArrayBitVector;
import it.unimi.dsi.logging.ProgressLogger;

/** Basic hash functions. */

public class Hashes {

	private Hashes() {}
	
	/** Jenkins 64-bit hashing (all three values produced).
	 * 
	 * <p>This code is based on the <samp><a href="http://www.burtleburtle.net/bob/c/lookup8.c">lookup8.c</a></samp>, and in particular
	 * on the version consuming 64 bits at a time, but it has been slightly modified to work correctly with any bit vector length (not just multiples of 64).
	 * Moreover, we return all three values generated by the algorithm.
	 * 
	 * <strong>Warning:</strong> in Sux4J 2.1, this function has been fixed (it was giving the same high bits on short keys) and
	 * returns different values.
	 * 
	 * @param bv a bit vector.
	 * @param seed a seed for the hash.
	 * @param h a triple of long values in which the three generated hashes will be saved.
	 */
	
	public static void jenkins( final BitVector bv, final long seed, final long[] h )  {
		final long length = bv.length();
		long a, b, c, from = 0;

		if ( length == 0 ) {
			h[ 0 ] = seed ^ 0x8de6a918d6538324L;
			h[ 1 ] = seed ^ 0x6bda2aef21654e7dL;
			h[ 2 ] = seed ^ 0x36071e726d0ba0c5L;
			return;
		}
		
		/* Set up the internal state */
		a = b = seed;
		c = 0x9e3779b97f4a7c13L; /* the golden ratio; an arbitrary value */

		while ( length - from > Long.SIZE * 2 ) {
			a += bv.getLong( from, from + Long.SIZE );
			b += bv.getLong( from + Long.SIZE, from + 2 * Long.SIZE );
			c += bv.getLong( from + 2 * Long.SIZE, Math.min( from + 3 * Long.SIZE, length ) );

			a -= b; a -= c; a ^= (c >>> 43);
			b -= c; b -= a; b ^= (a << 9);
			c -= a; c -= b; c ^= (b >>> 8);
			a -= b; a -= c; a ^= (c >>> 38);
			b -= c; b -= a; b ^= (a << 23);
			c -= a; c -= b; c ^= (b >>> 5);
			a -= b; a -= c; a ^= (c >>> 35);
			b -= c; b -= a; b ^= (a << 49);
			c -= a; c -= b; c ^= (b >>> 11);
			a -= b; a -= c; a ^= (c >>> 12);
			b -= c; b -= a; b ^= (a << 18);
			c -= a; c -= b; c ^= (b >>> 22);

			from += 3 * Long.SIZE;
		}

		c += length;
		long residual = length - from;
		if ( residual > 0 ) {
			if ( residual > Long.SIZE ) {
				a += bv.getLong( from, from + Long.SIZE );
				residual -= Long.SIZE;
			}
			if ( residual != 0 ) b += bv.getLong( length - residual, length );
		}

		a -= b; a -= c; a ^= (c >>> 43);
		b -= c; b -= a; b ^= (a << 9);
		c -= a; c -= b; c ^= (b >>> 8);
		a -= b; a -= c; a ^= (c >>> 38);
		b -= c; b -= a; b ^= (a << 23);
		c -= a; c -= b; c ^= (b >>> 5);
		a -= b; a -= c; a ^= (c >>> 35);
		b -= c; b -= a; b ^= (a << 49);
		c -= a; c -= b; c ^= (b >>> 11);
		a -= b; a -= c; a ^= (c >>> 12);
		b -= c; b -= a; b ^= (a << 18);
		c -= a; c -= b; c ^= (b >>> 22);

		h[ 0 ] = a;
		h[ 1 ] = b;
		h[ 2 ] = c;
	}

	/** Jenkins 64-bit hashing.
	 * 
	 * <strong>Warning:</strong> in Sux4J 2.1, this function has been fixed (it was giving the same high bits on short keys) and
	 * returns different values.
	 * 
	 * @param bv a bit vector.
	 * @param seed a seed for the hash.
	 * @return the first of the three hash values returned by {@link #jenkins(BitVector, long, long[])}.
	 */
	
	public static long jenkins( final BitVector bv, final long seed )  {
		final long length = bv.length();
		long a, b, c, from = 0;

		if ( length == 0 ) return seed ^ 0x8de6a918d6538324L;
		
		/* Set up the internal state */
		a = b = seed;
		c = 0x9e3779b97f4a7c13L; /* the golden ratio; an arbitrary value */

		while ( length - from > Long.SIZE * 2 ) {
			a += bv.getLong( from, from + Long.SIZE );
			b += bv.getLong( from + Long.SIZE, from + 2 * Long.SIZE );
			c += bv.getLong( from + 2 * Long.SIZE, Math.min( from + 3 * Long.SIZE, length ) );

			a -= b; a -= c; a ^= (c >>> 43);
			b -= c; b -= a; b ^= (a << 9);
			c -= a; c -= b; c ^= (b >>> 8);
			a -= b; a -= c; a ^= (c >>> 38);
			b -= c; b -= a; b ^= (a << 23);
			c -= a; c -= b; c ^= (b >>> 5);
			a -= b; a -= c; a ^= (c >>> 35);
			b -= c; b -= a; b ^= (a << 49);
			c -= a; c -= b; c ^= (b >>> 11);
			a -= b; a -= c; a ^= (c >>> 12);
			b -= c; b -= a; b ^= (a << 18);
			c -= a; c -= b; c ^= (b >>> 22);

			from += 3 * Long.SIZE;
		}

		c += length;
		long residual = length - from;
		if ( residual > 0 ) {
			if ( residual > Long.SIZE ) {
				a += bv.getLong( from, from + Long.SIZE );
				residual -= Long.SIZE;
			}
			if ( residual != 0 ) b += bv.getLong( length - residual, length );
		}

		//System.err.println( Long.toHexString( a ) + " " + Long.toHexString( b ) + " " + Long.toHexString( c ) );
		
		a -= b; a -= c; a ^= (c >>> 43);
		b -= c; b -= a; b ^= (a << 9);
		c -= a; c -= b; c ^= (b >>> 8);
		a -= b; a -= c; a ^= (c >>> 38);
		b -= c; b -= a; b ^= (a << 23);
		c -= a; c -= b; c ^= (b >>> 5);
		a -= b; a -= c; a ^= (c >>> 35);
		b -= c; b -= a; b ^= (a << 49);
		c -= a; c -= b; c ^= (b >>> 11);
		a -= b; a -= c; a ^= (c >>> 12);
		b -= c; b -= a; b ^= (a << 18);
		c -= a; c -= b; c ^= (b >>> 22);

		return c;
	}

	/** Jenkins 64-bit hashing.
	 * 
	 * <strong>Warning:</strong> in Sux4J 2.1, this function has been fixed (it was giving the same high bits on short keys) and
	 * returns different values.
	 * 
	 * @param bv a bit vector.
	 * @return the first of the three hash values returned by {@link #jenkins(BitVector, long, long[])} with seed 0.
	 */
	public static long jenkins( final BitVector bv )  {
		return jenkins( bv, 0 );
	}


	/** Preprocesses a bit vector so that Jenkins 64-bit hashing can be computed in constant time on all prefixes.
	 * 
	 * <strong>Warning:</strong> in Sux4J 2.1, this function has been fixed (it was giving the same high bits on short keys) and
	 * returns different values.
	 * 
	 * @param bv a bit vector.
	 * @param seed a seed for the hash.
	 * @return an array of three element; each element is an array containing the state of the variables <code>a</code>, <code>b</code> and <code>c</code>
	 * during the hash computation; these vector must be passed to {@link #jenkins(BitVector, long, long[], long[], long[])} (and analogous functions) in this order. 
	 * @see #jenkins(BitVector, long)
	 */
	
	public static long[][] preprocessJenkins( final BitVector bv, final long seed )  {
		final long length = bv.length();
		final int wordLength = (int)( length / ( Long.SIZE * 3 ) ) + 1;
		final long aa[] = new long[ wordLength ], bb[] = new long[ wordLength ], cc[] = new long[ wordLength ];
		long a, b, c, from = 0;

		if ( aa.length == 0 ) return new long[ 3 ][ 0 ];
		
		int i = 0;

		/* Set up the internal state */
		a = b = seed;
		c = 0x9e3779b97f4a7c13L; /* the golden ratio; an arbitrary value */

		aa[ i ] = a;
		bb[ i ] = b;
		cc[ i ] = c;
		i++;

		while ( length - from >= Long.SIZE * 3 ) {
			a += bv.getLong( from, from + Long.SIZE );
			b += bv.getLong( from + Long.SIZE, from + 2 * Long.SIZE );
			c += bv.getLong( from + 2 * Long.SIZE, from + 3 * Long.SIZE );

			a -= b; a -= c; a ^= (c >>> 43);
			b -= c; b -= a; b ^= (a << 9);
			c -= a; c -= b; c ^= (b >>> 8);
			a -= b; a -= c; a ^= (c >>> 38);
			b -= c; b -= a; b ^= (a << 23);
			c -= a; c -= b; c ^= (b >>> 5);
			a -= b; a -= c; a ^= (c >>> 35);
			b -= c; b -= a; b ^= (a << 49);
			c -= a; c -= b; c ^= (b >>> 11);
			a -= b; a -= c; a ^= (c >>> 12);
			b -= c; b -= a; b ^= (a << 18);
			c -= a; c -= b; c ^= (b >>> 22);

			from += 3 * Long.SIZE;
			
			aa[ i ] = a;
			bb[ i ] = b;
			cc[ i ] = c;
			i++;
		}
		
		return new long[][]{ aa, bb, cc };
	}

	/** Constant-time Jenkins 64-bit hashing for any prefix (all three values produced).
	 * 
	 * <strong>Warning:</strong> in Sux4J 2.1, this function has been fixed (it was giving the same high bits on short keys) and
	 * returns different values.
	 * 
	 * @param bv a bit vector.
	 * @param prefixLength the length of the prefix of <code>bv</code> over which the hash must be computed.
	 * @param aa the first state array returned by {@link #preprocessJenkins(BitVector, long)}.
	 * @param bb the second state array returned by {@link #preprocessJenkins(BitVector, long)}.
	 * @param cc the third state array returned by {@link #preprocessJenkins(BitVector, long)}.
	 * @param h a triple of long values in which the three generated hashes will be saved.
	 */
	
	public static void jenkins( final BitVector bv, final long prefixLength, final long[] aa, final long bb[], final long cc[], final long[] h )  {
		if ( prefixLength == 0 ) {
			final long seed = aa[ 0 ];
			h[ 0 ] = seed ^ 0x8de6a918d6538324L;
			h[ 1 ] = seed ^ 0x6bda2aef21654e7dL;
			h[ 2 ] = seed ^ 0x36071e726d0ba0c5L;
			return;
		}
		
		int stateOffset = (int)( prefixLength / ( 3 * Long.SIZE ) );
		long from = ( stateOffset * 3 ) * Long.SIZE;
		long a = aa[ stateOffset ];
		long b = bb[ stateOffset ];
		long c = cc[ stateOffset ];

		if ( prefixLength - from > Long.SIZE * 2 ) {
			a += bv.getLong( from, from + Long.SIZE );
			b += bv.getLong( from + Long.SIZE, from + 2 * Long.SIZE );
			c += bv.getLong( from + 2 * Long.SIZE, Math.min( from + 3 * Long.SIZE, prefixLength ) );

			a -= b; a -= c; a ^= (c >>> 43);
			b -= c; b -= a; b ^= (a << 9);
			c -= a; c -= b; c ^= (b >>> 8);
			a -= b; a -= c; a ^= (c >>> 38);
			b -= c; b -= a; b ^= (a << 23);
			c -= a; c -= b; c ^= (b >>> 5);
			a -= b; a -= c; a ^= (c >>> 35);
			b -= c; b -= a; b ^= (a << 49);
			c -= a; c -= b; c ^= (b >>> 11);
			a -= b; a -= c; a ^= (c >>> 12);
			b -= c; b -= a; b ^= (a << 18);
			c -= a; c -= b; c ^= (b >>> 22);

			from += 3 * Long.SIZE;
		}


		c += prefixLength;
		long residual = prefixLength - from;
		if ( residual > 0 ) {
			if ( residual > Long.SIZE ) {
				a += bv.getLong( from, from + Long.SIZE );
				residual -= Long.SIZE;
			}
			if ( residual != 0 ) b += bv.getLong( prefixLength - residual, prefixLength );
		}

		a -= b; a -= c; a ^= (c >>> 43);
		b -= c; b -= a; b ^= (a << 9);
		c -= a; c -= b; c ^= (b >>> 8);
		a -= b; a -= c; a ^= (c >>> 38);
		b -= c; b -= a; b ^= (a << 23);
		c -= a; c -= b; c ^= (b >>> 5);
		a -= b; a -= c; a ^= (c >>> 35);
		b -= c; b -= a; b ^= (a << 49);
		c -= a; c -= b; c ^= (b >>> 11);
		a -= b; a -= c; a ^= (c >>> 12);
		b -= c; b -= a; b ^= (a << 18);
		c -= a; c -= b; c ^= (b >>> 22);

		h[ 0 ] = a;
		h[ 1 ] = b;
		h[ 2 ] = c;
	}

	/** Constant-time Jenkins 64-bit hashing for any prefix.
	 * 
	 * <strong>Warning:</strong> in Sux4J 2.1, this function has been fixed (it was giving the same high bits on short keys) and
	 * returns different values.
	 * 
	 * @param bv a bit vector.
	 * @param prefixLength the length of the prefix of <code>bv</code> over which the hash must be computed.
	 * @param aa the first state array returned by {@link #preprocessJenkins(BitVector, long)}.
	 * @param bb the second state array returned by {@link #preprocessJenkins(BitVector, long)}.
	 * @param cc the third state array returned by {@link #preprocessJenkins(BitVector, long)}.
	 * @return the first of the three hash values returned by {@link #jenkins(BitVector, long, long[], long[], long[], long[])}.
	 */
	
	public static long jenkins( final BitVector bv, final long prefixLength, final long[] aa, final long bb[], final long cc[] )  {
		if ( prefixLength == 0 ) return aa[ 0 ] ^ 0x8de6a918d6538324L;
		
		int stateOffset = (int)( prefixLength / ( 3 * Long.SIZE ) );
		long from = ( stateOffset * 3 ) * Long.SIZE;
		long a = aa[ stateOffset ];
		long b = bb[ stateOffset ];
		long c = cc[ stateOffset ];

		if ( prefixLength - from > Long.SIZE * 2 ) {
			a += bv.getLong( from, from + Long.SIZE );
			b += bv.getLong( from + Long.SIZE, from + 2 * Long.SIZE );
			c += bv.getLong( from + 2 * Long.SIZE, Math.min( from + 3 * Long.SIZE, prefixLength ) );

			a -= b; a -= c; a ^= (c >>> 43);
			b -= c; b -= a; b ^= (a << 9);
			c -= a; c -= b; c ^= (b >>> 8);
			a -= b; a -= c; a ^= (c >>> 38);
			b -= c; b -= a; b ^= (a << 23);
			c -= a; c -= b; c ^= (b >>> 5);
			a -= b; a -= c; a ^= (c >>> 35);
			b -= c; b -= a; b ^= (a << 49);
			c -= a; c -= b; c ^= (b >>> 11);
			a -= b; a -= c; a ^= (c >>> 12);
			b -= c; b -= a; b ^= (a << 18);
			c -= a; c -= b; c ^= (b >>> 22);

			from += 3 * Long.SIZE;
		}


		c += prefixLength;
		long residual = prefixLength - from;
		if ( residual > 0 ) {
			if ( residual > Long.SIZE ) {
				a += bv.getLong( from, from + Long.SIZE );
				residual -= Long.SIZE;
			}
			if ( residual != 0 ) b += bv.getLong( prefixLength - residual, prefixLength );
		}

		a -= b; a -= c; a ^= (c >>> 43);
		b -= c; b -= a; b ^= (a << 9);
		c -= a; c -= b; c ^= (b >>> 8);
		a -= b; a -= c; a ^= (c >>> 38);
		b -= c; b -= a; b ^= (a << 23);
		c -= a; c -= b; c ^= (b >>> 5);
		a -= b; a -= c; a ^= (c >>> 35);
		b -= c; b -= a; b ^= (a << 49);
		c -= a; c -= b; c ^= (b >>> 11);
		a -= b; a -= c; a ^= (c >>> 12);
		b -= c; b -= a; b ^= (a << 18);
		c -= a; c -= b; c ^= (b >>> 22);

		return c;
	}

	/** Jenkins 64-bit hashing (all three values produced) for a triple of longs.
	 * 
	 * @param triple three longs.
	 * @param seed a seed for the hash.
	 * @param h a triple of long values in which the three generated hashes will be saved.
	 */
	
	public static void jenkins( final long[] triple, final long seed, final long[] h )  {
		long a, b, c;

		/* Set up the internal state */
		a = b = seed;
		c = 0x9e3779b97f4a7c13L; /* the golden ratio; an arbitrary value */

		a += triple[ 0 ];
		b += triple[ 1 ];
		c += triple[ 2 ];

		a -= b; a -= c; a ^= (c >>> 43);
		b -= c; b -= a; b ^= (a << 9);
		c -= a; c -= b; c ^= (b >>> 8);
		a -= b; a -= c; a ^= (c >>> 38);
		b -= c; b -= a; b ^= (a << 23);
		c -= a; c -= b; c ^= (b >>> 5);
		a -= b; a -= c; a ^= (c >>> 35);
		b -= c; b -= a; b ^= (a << 49);
		c -= a; c -= b; c ^= (b >>> 11);
		a -= b; a -= c; a ^= (c >>> 12);
		b -= c; b -= a; b ^= (a << 18);
		c -= a; c -= b; c ^= (b >>> 22);

		h[ 0 ] = a;
		h[ 1 ] = b;
		h[ 2 ] = c;
	}

	private static final long M = 0xc6a4a7935bd1e995L; 
	private static final int R = 47;
	
	/** MurmurHash 64-bit
	 * 
	 * <p>This code is based on a mix of the sources that can be found at
	 * <a href="http://sites.google.com/site/murmurhash/">MurmurHash's web site</a>, and in particular
	 * on the version consuming 64 bits at a time, which has been merged with the 2A version to obtain
	 * an {@linkplain #preprocessMurmur(BitVector, long) incremental implementation}.
	 * 
	 * @param bv a bit vector.
	 * @param seed a seed for the hash.
	 * @return the hash.
	 */
	public static long murmur( final BitVector bv, final long seed ) {
		long h = seed, k;
		long from = 0;
		final long length = bv.length();
		
		while( length - from >= Long.SIZE ) {
			k = bv.getLong( from, from += Long.SIZE );

			k *= M; 
			k ^= k >>> R; 
			k *= M; 

			h ^= k;
			h *= M;
		}
	
		if ( length > from ) {
			k = bv.getLong( from, length );
			k *= M; 
			k ^= k >>> R; 
			k *= M; 

			h ^= k;
			h *= M;
		}
		
		k = length;
		k *= M; 
		k ^= k >>> R; 
		k *= M; 

		h ^= k;
		h *= M;
		return h;
	}

	/** Constant-time MurmurHash 64-bit hashing for any prefix.
	 * 
	 * @param bv a bit vector.
	 * @param prefixLength the length of the prefix of <code>bv</code> over which the hash must be computed.
	 * @param state the state array returned by {@link #preprocessMurmur(BitVector, long)}.
	 * @return the hash for the prefix of <code>bv</code> or <code>prefixLength</code> bits.
	 */

	public static long murmur( final BitVector bv, final long prefixLength, final long[] state ) {
		final long precomputedUpTo = prefixLength - prefixLength % Long.SIZE;
		long h = state[ (int)( precomputedUpTo / Long.SIZE ) ], k;
		
		if ( prefixLength > precomputedUpTo ) {
			k = bv.getLong( precomputedUpTo, prefixLength );
			k *= M; 
			k ^= k >>> R; 
			k *= M; 

			h ^= k;
			h *= M;
		}
		
		k = prefixLength;
		k *= M; 
		k ^= k >>> R; 
		k *= M; 

		h ^= k;
		h *= M;
		return h;
		
	}
	
	/** Constant-time MurmurHash 64-bit hashing reusing precomputed state partially.
	 * 
	 * @param bv a bit vector.
	 * @param prefixLength the length of the prefix of <code>bv</code> over which the hash must be computed.
	 * @param state the state array returned by {@link #preprocessMurmur(BitVector, long)}.
	 * @param lcp the length of the longest common prefix between <code>bv</code> and the vector over which <code>state</code> was computed.
	 * @return the hash for the prefix of <code>bv</code> or <code>prefixLength</code> bits.
	 */

	public static long murmur( final BitVector bv, final long prefixLength, final long[] state, final long lcp ) {
		final int startStateWord = (int)( Math.min( lcp, prefixLength )  / Long.SIZE ); 
		long h = state[ startStateWord ], k;
		long from = startStateWord * Long.SIZE;
		
		while( prefixLength - from >= Long.SIZE ) {
			k = bv.getLong( from, from += Long.SIZE );

			k *= M; 
			k ^= k >>> R; 
			k *= M; 

			h ^= k;
			h *= M;
		}
	
		if ( prefixLength > from ) {
			k = bv.getLong( from, prefixLength );
			k *= M; 
			k ^= k >>> R; 
			k *= M; 

			h ^= k;
			h *= M;
		}
		
		k = prefixLength;
		k *= M; 
		k ^= k >>> R; 
		k *= M; 

		h ^= k;
		h *= M;
		return h;
	}
	
	/** Preprocesses a bit vector so that MurmurHash 64-bit can be computed in constant time on all prefixes.
	 * 
	 * @param bv a bit vector.
	 * @param seed a seed for the hash.
	 * @return an array containing the state of the variables <code>h</code>
	 * during the hash computation; these vector must be passed to {@link #murmur(BitVector, long, long[])} 
	 * (and analogous functions) in this order. 
	 * @see #murmur(BitVector, long)
	 */
	public static long[] preprocessMurmur( final BitVector bv, final long seed ) {
		long h = seed, k;
		long from = 0;
		final long length = bv.length();

		final int wordLength = (int)( length / Long.SIZE );
		final long state[] = new long[ wordLength + 1 ];

		int i = 0;
		state[ i++ ] = h;
		
		for( ; length - from >= Long.SIZE; i++ ) {
			k = bv.getLong( from, from += Long.SIZE );

			k *= M; 
			k ^= k >>> R; 
			k *= M; 

			h ^= k;
			h *= M;
			state[ i ] = h;
		}
	
		return state;
	}
	
	public static void main( String arg[] ) {
		final int l = Integer.parseInt( arg[ 0 ] );
		final int n = Integer.parseInt( arg[ 1 ] );
		LongArrayBitVector bv = LongArrayBitVector.ofLength( l );
		
		ProgressLogger pl = new ProgressLogger();
		long t = 0;
		
		pl.start( "Timing MurmurHash..." );
		
		for( int i = n; i-- != 0; ) t += murmur( bv, 0 );
		if ( t == -1 ) System.err.println( t ); // To avoid elision
		
		pl.count = n;
		pl.done();
		
		pl.start( "Timing Jenkins's hash..." );
		
		for( int i = n; i-- != 0; ) t += jenkins( bv, 0 );
		if ( t == -1 ) System.err.println( t ); // To avoid elision
		
		pl.count = n;
		pl.done();
	}
}
